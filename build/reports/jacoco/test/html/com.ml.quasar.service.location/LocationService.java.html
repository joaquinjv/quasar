<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>LocationService.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">quasar</a> &gt; <a href="index.source.html" class="el_package">com.ml.quasar.service.location</a> &gt; <span class="el_source">LocationService.java</span></div><h1>LocationService.java</h1><pre class="source lang-java linenums">package com.ml.quasar.service.location;

import java.util.List;

import org.apache.commons.math3.fitting.leastsquares.LevenbergMarquardtOptimizer;
import org.springframework.stereotype.Service;

import com.lemmingapex.trilateration.NonLinearLeastSquaresSolver;
import com.lemmingapex.trilateration.TrilaterationFunction;
import com.ml.quasar.model.vo.PositionVo;
import com.ml.quasar.model.vo.SatelliteVo;

@Service
<span class="fc" id="L14">public class LocationService implements I_LocationService {</span>
	
	public double[] getLocation(List&lt;PositionVo&gt; positions, List&lt;SatelliteVo&gt; satellites) {
		
<span class="fc" id="L18">		double[] point1 = new double[] {positions.get(0).getX(), positions.get(0).getY()};</span>
<span class="fc" id="L19">		double[] point2 = new double[] {positions.get(1).getX(), positions.get(1).getY()};</span>
<span class="fc" id="L20">		double[] point3 = new double[] {positions.get(2).getX(), positions.get(2).getY()};</span>
<span class="fc" id="L21">		double[][] positionsToCalculate = new double[][] { point1, point2, point3 };</span>
		
<span class="fc" id="L23">		double[] distances = this.getDistancesFromSatellites(satellites);</span>
<span class="fc" id="L24">        TrilaterationFunction trilaterationFunction = new TrilaterationFunction(positionsToCalculate, distances);</span>
<span class="fc" id="L25">        NonLinearLeastSquaresSolver nSolver = new NonLinearLeastSquaresSolver(trilaterationFunction, new LevenbergMarquardtOptimizer());</span>
<span class="fc" id="L26">        return nSolver.solve().getPoint().toArray();</span>
    }

	public double[] getHandLocation(List&lt;PositionVo&gt; positions, List&lt;SatelliteVo&gt; satellites) {
<span class="fc" id="L30">		double[] distances = this.getDistancesFromSatellites(satellites);</span>
		
<span class="fc" id="L32">		return _getHandLocation(positions, distances);</span>
	}
	
	private double[] getDistancesFromSatellites(List&lt;SatelliteVo&gt; satellites) {
<span class="fc" id="L36">		double[] distances = new double[satellites.size()];</span>
		// We get the distances
<span class="fc bfc" id="L38" title="All 2 branches covered.">		for (int i = 0; i &lt; satellites.size(); i++) {</span>
<span class="fc" id="L39">			distances[i] = satellites.get(i).getDistance();</span>
		}
<span class="fc" id="L41">		return distances;</span>
	}

	public double[] _getHandLocation(List&lt;PositionVo&gt; positions, double[] distances) {

<span class="fc" id="L46">		double[] point1 = new double[] {positions.get(0).getX(), positions.get(0).getY()};</span>
<span class="fc" id="L47">		double[] point2 = new double[] {positions.get(1).getX(), positions.get(1).getY()};</span>
<span class="fc" id="L48">		double[] point3 = new double[] {positions.get(2).getX(), positions.get(2).getY()};</span>

<span class="fc" id="L50">		double[] ex = new double[2];</span>
<span class="fc" id="L51">		double[] ey = new double[2];</span>
<span class="fc" id="L52">		double[] substractP3P1 = new double[2];</span>

<span class="fc" id="L54">		double jResult = 0;</span>
<span class="fc" id="L55">		double powSubstractP2P1 = 0;</span>
<span class="fc" id="L56">		double iResult = 0;</span>
<span class="fc" id="L57">		double divisionP3P1i = 0;</span>

		double resultX;
		double resultY;

		double xval;
		double yval;
		double divisionResult;

<span class="fc" id="L66">		double distance1 = distances[0];</span>
<span class="fc" id="L67">		double distance2 = distances[1];</span>
<span class="fc" id="L68">		double distance3 = distances[2];</span>
		
		/**
		 *  We are supported by a formula to do this calculus, it is:
		 * 
		 *  FORMULA
		 *
		 *	(x0−x1)^2 + (y0−y1)^2 = d1^2
		 *	(x0−x2)^2 + (y0−y2)^2 = d2^2
		 *	(x0−x3)^2 + (y0−y3)^2 = d2^3
		 *	
		 *	where x0 = ? and y0 = ?, we don't have this information.
		 *
		 *  For example for the points P1 = (-500,-200), P2 = (100,-100), P3 = (500,100), and distances d1 = 100, d2 = 115.5, d3 = 142.7, we have something like this:
		 *
		 *	(x0 + 500)^2 + (y0 + 200)^2 = 100.0^2
		 *	(x0 - 100)^2 + (y0 + 100)^2 = 115.5^2
		 *  (x0 - 500)^2 + (y0 - 100)^2 = 142.7^2
		 * 
		 *  We know that this expression, ex = (P2 - P1) / ‖P2 - P1‖ means:
         *
		 *	ex,x = (P2x - P1x) / sqrt((P2x - P1x)2 + (P2y - P1y)2)
		 *	ex,y = (P2y - P1y) / sqrt((P2x - P1x)2 + (P2y - P1y)2)
         *
         *  And the calculation steps are:
         * 
		 *  ex = (P2 - P1) / ‖P2 - P1‖
		 *  iResult = ex(P3 - P1)
		 *  ey = (P3 - P1 - iResult · ex) / ‖P3 - P1 - iResult · ex‖ -&gt; (P3x - P1x - iResult * ex) / sqrt((P3x - P1x - iResult · ex)^2 + (P3y - P3y - iResult · ex)^2) 
		 *  divisionResult = ‖P2 - P1‖ // This is a partial calculus in the algorithm
		 *  jResult = ey(P3 - P1)
		 *  xval = (r1^2 - r2^2 + divisionResult^2) / 2 * divisionResult
		 *  yval = (r1^2 - r3^2 + i^2 + jResult^2) / 2 * jResult - ix / j
		 * 
		 */
		
		/**
		 * A generic way to do that, because we have to repeat for &quot;x&quot; and &quot;y&quot; the same calculus,
		 * If not, we have something like that
		 * 
		 * d = Math.sqrt(Math.pow(P2[0] - P1[0], 2) + Math.pow(P2[1] - P1[1], 2));
		 * and
		 * ex[0] = (P2[0] - P1[0]) / d; ex[1] = (P2[1] - P1[1]) / d;
		 * 
		 * So, we repeat every time the same calculus for pos 0 and 1, or &quot;x&quot; and &quot;y&quot;
		 * 
		 */
		
<span class="fc bfc" id="L116" title="All 2 branches covered.">		for (int i = 0; i &lt; point1.length; i++) powSubstractP2P1 += Math.pow(point2[i] - point1[i], 2);</span>
<span class="fc" id="L117">		divisionResult = Math.sqrt(powSubstractP2P1);</span>
<span class="fc bfc" id="L118" title="All 2 branches covered.">		for (int i = 0; i &lt; point1.length; i++) ex[i] = (point2[i] - point1[i]) / divisionResult;</span>
<span class="fc bfc" id="L119" title="All 2 branches covered.">		for (int i = 0; i &lt; point3.length; i++) substractP3P1[i] = point3[i] - point1[i];</span>
//		for (int i = 0; i &lt; ex.length; i++) iResult += Math.pow(ex[i] - substractP3P1[i], 2);
<span class="fc bfc" id="L121" title="All 2 branches covered.">		for (int i = 0; i &lt; ex.length; i++) iResult += ex[i] * substractP3P1[i];</span>
<span class="fc bfc" id="L122" title="All 2 branches covered.">		for (int i = 0; i &lt; ex.length; i++) divisionP3P1i += Math.pow(point3[i] - point1[i] - iResult * ex[i], 2);</span>
<span class="fc bfc" id="L123" title="All 2 branches covered.">		for (int i = 0; i &lt; point3.length; i++) ey[i] += (point3[i] - point1[i] - ex[i] * iResult) / Math.sqrt(divisionP3P1i);</span>
//		for (int i = 0; i &lt; ey.length; i++) jResult += Math.pow(ey[i] - substractP3P1[i], 2);
<span class="fc bfc" id="L125" title="All 2 branches covered.">		for (int i = 0; i &lt; ey.length; i++) jResult += ey[i] * substractP3P1[i];</span>
		
<span class="fc" id="L127">		xval = (Math.pow(distance1, 2) - Math.pow(distance2, 2) + Math.pow(divisionResult, 2)) / (2 * divisionResult);</span>
//		yval = ((Math.pow(distance1, 2) - Math.pow(distance3, 2) + Math.pow(iResult, 2) + Math.pow(jResult, 2)) / (2 * jResult)) - ((iResult / jResult) * xval);
<span class="fc" id="L129">		yval = ((Math.pow(distance1, 2) - Math.pow(distance3, 2) + Math.pow(iResult, 2) + Math.pow(jResult, 2)) / (2 * jResult)) - ((iResult*xval / jResult));</span>

<span class="fc" id="L131">		resultX = (ex[0] * xval) + (ey[0] * yval);</span>
<span class="fc" id="L132">		resultY = (ex[1] * xval) + (ey[1] * yval);</span>

<span class="fc" id="L134">		double[] result = new double[2];</span>
<span class="fc" id="L135">		result[0] = resultX;</span>
<span class="fc" id="L136">		result[1] = resultY;</span>
<span class="fc" id="L137">		return result;</span>

    }
	
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>